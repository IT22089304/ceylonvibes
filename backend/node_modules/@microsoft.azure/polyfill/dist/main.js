"use strict";
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
// Async Iterator support 
require('source-map-support').install({ hookRequire: true });
require("../bluebird-stacktraces");
__export(require("./lib/exception"));
__export(require("./lib/outstanding-task-awaiter"));
__export(require("./lib/lazy-promise"));
__export(require("./lib/lazy"));
/**
 * Creates a shallow copy of a given object by copying the properties to a new object
 * Note: this does not copy the method prototypes, so it's a shallow data copy only.
 *
 * @param {input} any javascript object
 * @param {filter} Array<string> of properties to filter out from the copy.
 */
function shallowCopy(input, ...filter) {
    if (!input) {
        return input;
    }
    const keys = input.Keys ? input.Keys : Object.getOwnPropertyNames(input);
    const result = {};
    for (const key of keys) {
        if (filter.indexOf(key) == -1) {
            const value = input[key];
            if (value !== undefined) {
                result[key] = value;
            }
        }
    }
    return result;
}
exports.shallowCopy = shallowCopy;
function Delay(delayMS) {
    return new Promise(res => setTimeout(res, delayMS));
}
exports.Delay = Delay;
class ManualPromise {
    constructor() {
        this.resolve = (v) => { };
        this.reject = (e) => { };
        this.p = new Promise((r, j) => { this.resolve = r; this.reject = j; });
    }
    then(onfulfilled, onrejected) {
        return this.p.then(onfulfilled);
    }
    catch(onrejected) {
        return this.p.catch(onrejected);
    }
}
exports.ManualPromise = ManualPromise;
class CriticalSection {
    async enter() {
        while (this.promise) {
            await Delay(10);
            // wait for its release
            await this.promise;
            // make sure it's still not busy
            if (this.promise) {
                continue;
            }
        }
        this.promise = new ManualPromise();
    }
    async exit() {
        const p = this.promise;
        this.promise = undefined;
        if (p) {
            p.resolve();
        }
    }
}
exports.CriticalSection = CriticalSection;
/**
 * Asynchronously waits for the predicate condition to turn false, with a delay between checks
 * @param predicate - a fn that returns a boolean
 * @param delay - number of milliseconds to async delay between checks.
 */
async function While(predicate, delay = 50) {
    while (predicate()) {
        await Delay(delay);
    }
}
exports.While = While;
/**
 * Asynchronously waits for the predicate condition to turn true, with a delay between checks
 * @param predicate - a fn that returns a boolean
 * @param delay - number of milliseconds to async delay between checks.
 */
async function Until(predicate, delay = 50) {
    while (predicate()) {
        await Delay(delay);
    }
}
exports.Until = Until;
/**
 * An async wrapper for waiting for an event to trigger once
 * @param emitter - an event emitter
 * @param event - the name of the event to wait for.
 */
function When(emitter, event) {
    return new Promise((r, j) => emitter.once(event, r));
}
exports.When = When;
//# sourceMappingURL=main.js.map